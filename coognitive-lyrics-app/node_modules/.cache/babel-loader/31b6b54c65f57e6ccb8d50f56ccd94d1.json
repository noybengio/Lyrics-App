{"ast":null,"code":"/*!\n * Clamp.js 0.7.0\n * Based on: https://github.com/xavi160/Clamp.js/commit/e313818da231b8dd8fd603dd9c9a61a9d725c22f\n * Mixins:\n * - https://github.com/josephschmitt/Clamp.js/pull/50\n * - https://github.com/josephschmitt/Clamp.js/pull/49\n *\n * Copyright 2011-2013, Joseph Schmitt http://joe.sh\n * Released under the WTFPL license\n * http://sam.zoy.org/wtfpl/\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.$clamp = factory();\n  }\n})(this, function () {\n  /**\n   * Clamps a text node.\n   * @param {HTMLElement} element. Element containing the text node to clamp.\n   * @param {Object} options. Options to pass to the clamper.\n   */\n  function clamp(element, options) {\n    options = options || {};\n    var self = this,\n        win = window,\n        opt = {\n      clamp: options.clamp || 2,\n      useNativeClamp: typeof options.useNativeClamp != 'undefined' ? options.useNativeClamp : true,\n      splitOnChars: options.splitOnChars || ['.', '-', '–', '—', ' '],\n      //Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).\n      animate: options.animate || false,\n      truncationChar: options.truncationChar || '…',\n      truncationHTML: options.truncationHTML\n    },\n        sty = element.style,\n        originalText = element.innerHTML,\n        supportsNativeClamp = typeof element.style.webkitLineClamp != 'undefined',\n        clampValue = opt.clamp,\n        isCSSValue = clampValue.indexOf && (clampValue.indexOf('px') > -1 || clampValue.indexOf('em') > -1),\n        truncationHTMLContainer;\n\n    if (opt.truncationHTML) {\n      truncationHTMLContainer = document.createElement('span');\n      truncationHTMLContainer.innerHTML = opt.truncationHTML;\n    } // UTILITY FUNCTIONS __________________________________________________________\n\n    /**\n     * Return the current style for an element.\n     * @param {HTMLElement} elem The element to compute.\n     * @param {string} prop The style property.\n     * @returns {number}\n     */\n\n\n    function computeStyle(elem, prop) {\n      if (!win.getComputedStyle) {\n        win.getComputedStyle = function (el, pseudo) {\n          this.el = el;\n\n          this.getPropertyValue = function (prop) {\n            var re = /(\\-([a-z]){1})/g;\n            if (prop == 'float') prop = 'styleFloat';\n\n            if (re.test(prop)) {\n              prop = prop.replace(re, function () {\n                return arguments[2].toUpperCase();\n              });\n            }\n\n            return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;\n          };\n\n          return this;\n        };\n      }\n\n      return win.getComputedStyle(elem, null).getPropertyValue(prop);\n    }\n    /**\n     * Returns the maximum number of lines of text that should be rendered based\n     * on the current height of the element and the line-height of the text.\n     */\n\n\n    function getMaxLines(height) {\n      var availHeight = height || element.parentNode.clientHeight - element.offsetTop,\n          lineHeight = getLineHeight(element);\n      return Math.max(Math.floor(availHeight / lineHeight), 0);\n    }\n    /**\n     * Returns the maximum height a given element should have based on the line-\n     * height of the text and the given clamp value.\n     */\n\n\n    function getMaxHeight(clmp) {\n      var lineHeight = getLineHeight(element);\n      return lineHeight * clmp;\n    }\n    /**\n     * Returns the line-height of an element as an integer.\n     */\n\n\n    function getLineHeight(elem) {\n      var lh = computeStyle(elem, 'line-height');\n\n      if (lh == 'normal') {\n        // Normal line heights vary from browser to browser. The spec recommends\n        // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.\n        lh = parseFloat(computeStyle(elem, 'font-size')) * 1.2;\n      }\n\n      return Math.round(parseFloat(lh));\n    } // MEAT AND POTATOES (MMMM, POTATOES...) ______________________________________\n\n\n    var splitOnChars = opt.splitOnChars.slice(0),\n        splitChar = splitOnChars[0],\n        chunks,\n        lastChunk;\n    /**\n     * Gets an element's last child. That may be another node or a node's contents.\n     */\n\n    function getLastChild(elem) {\n      if (!elem.lastChild) {\n        return;\n      } //Current element has children, need to go deeper and get last child as a text node\n\n\n      if (elem.lastChild.children && elem.lastChild.children.length > 0) {\n        return getLastChild(Array.prototype.slice.call(elem.children).pop());\n      } else if (!elem.lastChild || !elem.lastChild.nodeValue || elem.lastChild.nodeValue == opt.truncationChar || elem.lastChild.nodeType === Node.COMMENT_NODE) {\n        // Handle scenario where the last child is white-space node\n        var sibling = elem.lastChild;\n\n        do {\n          if (!sibling) {\n            return;\n          } // TEXT_NODE\n\n\n          if (sibling.nodeType === 3 && ['', opt.truncationChar].indexOf(sibling.nodeValue) === -1 && elem.lastChild.nodeType !== Node.COMMENT_NODE) {\n            return sibling;\n          }\n\n          if (sibling.lastChild) {\n            var lastChild = getLastChild(sibling);\n\n            if (lastChild) {\n              return lastChild;\n            }\n          } //Current sibling is pretty useless\n\n\n          sibling.parentNode.removeChild(sibling);\n        } while (sibling = sibling.previousSibling);\n      } //This is the last child we want, return it\n      else {\n          return elem.lastChild;\n        }\n    }\n    /**\n     * Removes one character at a time from the text until its width or\n     * height is beneath the passed-in max param.\n     */\n\n\n    function truncate(target, maxHeight) {\n      if (!target || !maxHeight) {\n        return;\n      }\n      /**\n       * Resets global variables.\n       */\n\n\n      function reset() {\n        splitOnChars = opt.splitOnChars.slice(0);\n        splitChar = splitOnChars[0];\n        chunks = null;\n        lastChunk = null;\n      }\n\n      var nodeValue = target.nodeValue.replace(opt.truncationChar, ''); //Grab the next chunks\n\n      if (!chunks) {\n        //If there are more characters to try, grab the next one\n        if (splitOnChars.length > 0) {\n          splitChar = splitOnChars.shift();\n        } //No characters to chunk by. Go character-by-character\n        else {\n            splitChar = '';\n          }\n\n        chunks = nodeValue.split(splitChar);\n      } //If there are chunks left to remove, remove the last one and see if\n      // the nodeValue fits.\n\n\n      if (chunks.length > 1) {\n        // console.log('chunks', chunks);\n        lastChunk = chunks.pop(); // console.log('lastChunk', lastChunk);\n\n        applyEllipsis(target, chunks.join(splitChar));\n      } //No more chunks can be removed using this character\n      else {\n          chunks = null;\n        } //Insert the custom HTML before the truncation character\n\n\n      if (truncationHTMLContainer) {\n        target.nodeValue = target.nodeValue.replace(opt.truncationChar, '');\n        element.innerHTML = target.nodeValue + ' ' + truncationHTMLContainer.innerHTML + opt.truncationChar;\n      } //Search produced valid chunks\n\n\n      if (chunks) {\n        //It fits\n        if (element.clientHeight <= maxHeight) {\n          //There's still more characters to try splitting on, not quite done yet\n          if (splitOnChars.length >= 0 && splitChar !== '') {\n            applyEllipsis(target, chunks.join(splitChar) + splitChar + lastChunk);\n            chunks = null;\n          } //Finished!\n          else {\n              return element.innerHTML;\n            }\n        }\n      } //No valid chunks produced\n      else {\n          //No valid chunks even when splitting by letter, time to move\n          //on to the next node\n          if (splitChar === '') {\n            applyEllipsis(target, '');\n            target = getLastChild(element);\n            reset();\n          }\n        } //If you get here it means still too big, let's keep truncating\n\n\n      if (opt.animate) {\n        setTimeout(function () {\n          truncate(target, maxHeight);\n        }, opt.animate === true ? 10 : opt.animate);\n      } else {\n        return truncate(target, maxHeight);\n      }\n    }\n\n    function applyEllipsis(elem, str) {\n      elem.nodeValue = str + opt.truncationChar;\n    } // CONSTRUCTOR ________________________________________________________________\n\n\n    if (clampValue == 'auto') {\n      clampValue = getMaxLines();\n    } else if (isCSSValue) {\n      clampValue = getMaxLines(parseInt(clampValue, 10));\n    }\n\n    var clampedText;\n\n    if (supportsNativeClamp && opt.useNativeClamp) {\n      sty.overflow = 'hidden';\n      sty.textOverflow = 'ellipsis';\n      sty.webkitBoxOrient = 'vertical';\n      sty.display = '-webkit-box';\n      sty.webkitLineClamp = clampValue;\n\n      if (isCSSValue) {\n        sty.height = opt.clamp + 'px';\n      }\n    } else {\n      var height = getMaxHeight(clampValue);\n\n      if (height < element.clientHeight) {\n        clampedText = truncate(getLastChild(element), height);\n      }\n    }\n\n    return {\n      'original': originalText,\n      'clamped': clampedText\n    };\n  }\n\n  return clamp;\n});","map":{"version":3,"sources":["C:/Users/נוי בנג'ו/Documents/ראיונות עבודה/coognitive/coognitive-lyrics-app/node_modules/react-dotdotdot/src/clamp.js"],"names":["root","factory","define","amd","exports","module","$clamp","clamp","element","options","self","win","window","opt","useNativeClamp","splitOnChars","animate","truncationChar","truncationHTML","sty","style","originalText","innerHTML","supportsNativeClamp","webkitLineClamp","clampValue","isCSSValue","indexOf","truncationHTMLContainer","document","createElement","computeStyle","elem","prop","getComputedStyle","el","pseudo","getPropertyValue","re","test","replace","arguments","toUpperCase","currentStyle","getMaxLines","height","availHeight","parentNode","clientHeight","offsetTop","lineHeight","getLineHeight","Math","max","floor","getMaxHeight","clmp","lh","parseFloat","round","slice","splitChar","chunks","lastChunk","getLastChild","lastChild","children","length","Array","prototype","call","pop","nodeValue","nodeType","Node","COMMENT_NODE","sibling","removeChild","previousSibling","truncate","target","maxHeight","reset","shift","split","applyEllipsis","join","setTimeout","str","parseInt","clampedText","overflow","textOverflow","webkitBoxOrient","display"],"mappings":"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","sourcesContent":["/*!\n * Clamp.js 0.7.0\n * Based on: https://github.com/xavi160/Clamp.js/commit/e313818da231b8dd8fd603dd9c9a61a9d725c22f\n * Mixins:\n * - https://github.com/josephschmitt/Clamp.js/pull/50\n * - https://github.com/josephschmitt/Clamp.js/pull/49\n *\n * Copyright 2011-2013, Joseph Schmitt http://joe.sh\n * Released under the WTFPL license\n * http://sam.zoy.org/wtfpl/\n */\n\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.$clamp = factory();\n  }\n}(this, function() {\n  /**\n   * Clamps a text node.\n   * @param {HTMLElement} element. Element containing the text node to clamp.\n   * @param {Object} options. Options to pass to the clamper.\n   */\n  function clamp(element, options) {\n    options = options || {};\n\n    var self = this,\n      win = window,\n      opt = {\n        clamp: options.clamp || 2,\n        useNativeClamp: typeof(options.useNativeClamp) != 'undefined' ? options.useNativeClamp : true,\n        splitOnChars: options.splitOnChars || ['.', '-', '–', '—', ' '], //Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).\n        animate: options.animate || false,\n        truncationChar: options.truncationChar || '…',\n        truncationHTML: options.truncationHTML\n      },\n\n      sty = element.style,\n      originalText = element.innerHTML,\n\n      supportsNativeClamp = typeof(element.style.webkitLineClamp) != 'undefined',\n      clampValue = opt.clamp,\n      isCSSValue = clampValue.indexOf && (clampValue.indexOf('px') > -1 || clampValue.indexOf('em') > -1),\n      truncationHTMLContainer;\n\n    if (opt.truncationHTML) {\n      truncationHTMLContainer = document.createElement('span');\n      truncationHTMLContainer.innerHTML = opt.truncationHTML;\n    }\n\n\n    // UTILITY FUNCTIONS __________________________________________________________\n\n    /**\n     * Return the current style for an element.\n     * @param {HTMLElement} elem The element to compute.\n     * @param {string} prop The style property.\n     * @returns {number}\n     */\n    function computeStyle(elem, prop) {\n      if (!win.getComputedStyle) {\n        win.getComputedStyle = function(el, pseudo) {\n          this.el = el;\n          this.getPropertyValue = function(prop) {\n            var re = /(\\-([a-z]){1})/g;\n            if (prop == 'float') prop = 'styleFloat';\n            if (re.test(prop)) {\n              prop = prop.replace(re, function() {\n                return arguments[2].toUpperCase();\n              });\n            }\n            return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;\n          };\n          return this;\n        };\n      }\n\n      return win.getComputedStyle(elem, null).getPropertyValue(prop);\n    }\n\n    /**\n     * Returns the maximum number of lines of text that should be rendered based\n     * on the current height of the element and the line-height of the text.\n     */\n    function getMaxLines(height) {\n      var availHeight = height || (element.parentNode.clientHeight-element.offsetTop),\n        lineHeight = getLineHeight(element);\n\n      return Math.max(Math.floor(availHeight / lineHeight), 0);\n    }\n\n    /**\n     * Returns the maximum height a given element should have based on the line-\n     * height of the text and the given clamp value.\n     */\n    function getMaxHeight(clmp) {\n      var lineHeight = getLineHeight(element);\n      return lineHeight * clmp;\n    }\n\n    /**\n     * Returns the line-height of an element as an integer.\n     */\n    function getLineHeight(elem) {\n      var lh = computeStyle(elem, 'line-height');\n      if (lh == 'normal') {\n        // Normal line heights vary from browser to browser. The spec recommends\n        // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.\n        lh = parseFloat(computeStyle(elem, 'font-size')) * 1.2;\n      }\n      return Math.round(parseFloat(lh));\n    }\n\n\n    // MEAT AND POTATOES (MMMM, POTATOES...) ______________________________________\n    var splitOnChars = opt.splitOnChars.slice(0),\n      splitChar = splitOnChars[0],\n      chunks,\n      lastChunk;\n\n    /**\n     * Gets an element's last child. That may be another node or a node's contents.\n     */\n    function getLastChild(elem) {\n      if (!elem.lastChild) {\n        return;\n      }\n      //Current element has children, need to go deeper and get last child as a text node\n      if (elem.lastChild.children && elem.lastChild.children.length > 0) {\n        return getLastChild(Array.prototype.slice.call(elem.children).pop());\n      } else if (\n        !elem.lastChild\n        || !elem.lastChild.nodeValue\n        || elem.lastChild.nodeValue == opt.truncationChar\n        || elem.lastChild.nodeType === Node.COMMENT_NODE\n      ) {\n        // Handle scenario where the last child is white-space node\n        var sibling = elem.lastChild;\n        do {\n          if (!sibling) {\n            return;\n          }\n          // TEXT_NODE\n          if (\n            sibling.nodeType === 3\n            && ['', opt.truncationChar].indexOf(sibling.nodeValue) === -1\n            && elem.lastChild.nodeType !== Node.COMMENT_NODE\n          ) {\n            return sibling;\n          }\n          if (sibling.lastChild) {\n            var lastChild = getLastChild(sibling);\n            if (lastChild) {\n              return lastChild;\n            }\n          }\n          //Current sibling is pretty useless\n          sibling.parentNode.removeChild(sibling);\n        } while (sibling = sibling.previousSibling);\n      }\n      //This is the last child we want, return it\n      else {\n        return elem.lastChild;\n      }\n    }\n\n    /**\n     * Removes one character at a time from the text until its width or\n     * height is beneath the passed-in max param.\n     */\n    function truncate(target, maxHeight) {\n      if (!target || !maxHeight) {\n        return;\n      }\n\n      /**\n       * Resets global variables.\n       */\n      function reset() {\n        splitOnChars = opt.splitOnChars.slice(0);\n        splitChar = splitOnChars[0];\n        chunks = null;\n        lastChunk = null;\n      }\n\n      var nodeValue = target.nodeValue.replace(opt.truncationChar, '');\n\n      //Grab the next chunks\n      if (!chunks) {\n        //If there are more characters to try, grab the next one\n        if (splitOnChars.length > 0) {\n          splitChar = splitOnChars.shift();\n        }\n        //No characters to chunk by. Go character-by-character\n        else {\n          splitChar = '';\n        }\n\n        chunks = nodeValue.split(splitChar);\n      }\n\n      //If there are chunks left to remove, remove the last one and see if\n      // the nodeValue fits.\n      if (chunks.length > 1) {\n        // console.log('chunks', chunks);\n        lastChunk = chunks.pop();\n        // console.log('lastChunk', lastChunk);\n        applyEllipsis(target, chunks.join(splitChar));\n      }\n      //No more chunks can be removed using this character\n      else {\n        chunks = null;\n      }\n\n      //Insert the custom HTML before the truncation character\n      if (truncationHTMLContainer) {\n        target.nodeValue = target.nodeValue.replace(opt.truncationChar, '');\n        element.innerHTML = target.nodeValue + ' ' + truncationHTMLContainer.innerHTML + opt.truncationChar;\n      }\n\n      //Search produced valid chunks\n      if (chunks) {\n        //It fits\n        if (element.clientHeight <= maxHeight) {\n          //There's still more characters to try splitting on, not quite done yet\n          if (splitOnChars.length >= 0 && splitChar !== '') {\n            applyEllipsis(target, chunks.join(splitChar) + splitChar + lastChunk);\n            chunks = null;\n          }\n          //Finished!\n          else {\n            return element.innerHTML;\n          }\n        }\n      }\n      //No valid chunks produced\n      else {\n        //No valid chunks even when splitting by letter, time to move\n        //on to the next node\n        if (splitChar === '') {\n          applyEllipsis(target, '');\n          target = getLastChild(element);\n\n          reset();\n        }\n      }\n\n      //If you get here it means still too big, let's keep truncating\n      if (opt.animate) {\n        setTimeout(function() {\n          truncate(target, maxHeight);\n        }, opt.animate === true ? 10 : opt.animate);\n      } else {\n        return truncate(target, maxHeight);\n      }\n    }\n\n    function applyEllipsis(elem, str) {\n      elem.nodeValue = str + opt.truncationChar;\n    }\n\n\n    // CONSTRUCTOR ________________________________________________________________\n\n    if (clampValue == 'auto') {\n      clampValue = getMaxLines();\n    } else if (isCSSValue) {\n      clampValue = getMaxLines(parseInt(clampValue, 10));\n    }\n\n    var clampedText;\n    if (supportsNativeClamp && opt.useNativeClamp) {\n      sty.overflow = 'hidden';\n      sty.textOverflow = 'ellipsis';\n      sty.webkitBoxOrient = 'vertical';\n      sty.display = '-webkit-box';\n      sty.webkitLineClamp = clampValue;\n\n      if (isCSSValue) {\n        sty.height = opt.clamp + 'px';\n      }\n    } else {\n      var height = getMaxHeight(clampValue);\n      if (height < element.clientHeight) {\n        clampedText = truncate(getLastChild(element), height);\n      }\n    }\n\n    return {\n      'original': originalText,\n      'clamped': clampedText\n    };\n  }\n\n  return clamp;\n}));\n"]},"metadata":{},"sourceType":"script"}